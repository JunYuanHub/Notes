## 深拷贝与浅拷贝  
二者都是针对引用类型而言的，基本数据类型按照值传递，引用类型按照指针传递。  
  
浅拷贝拷贝时，只复制对象的一层，对于引用类型只复制指针（存在修改源对象，所有引用对象都改变的情况）  
深拷贝则会创建一个一样的对象并占有新的内存。  
  
浅拷贝：Object.assign;slice;concat都是  
深拷贝：1. 手动；2.递归（怕循环调用）；3.JSON.stringify再parse(存在bug)  
## 手动实现 
### 浅拷贝  
```  
function cloneShallow(source) {
    var target = {};
    for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
        }
    }
    return target;
}
``` 
在常用的：JSON.parse(JSON.stringify(obj))中存在漏洞：  
~~~  
1. json转化会失去函数、特殊对象(RegExp)
2. 原型链断链(失去constructor)，所有构造函数指向Object
3. 循环引用会报错
~~~
实现方法：  
~~~  
// 这里把数组也考虑了进来
function deepClone(someObj) {
  const { toString } = Object.prototype;
  const isObject = o => toString.call(o).slice(8, -1) === 'Object';

  function _deepClone(source) {
    if (Array.isArray(source)) { // 处理数组
      return source.reduce((res, item) => {
        res.push(_deepClone(item));
        return res;
      }, []);
    }

    if (isObject(source)) { // 处理对象
      return Object.keys(source).reduce((res, key) => {
        res[key] = _deepClone(source[key]);
        return res;
      }, {});
    }

    return source; // 处理其他类型
  }

  return _deepClone(someObj);
}
~~~
