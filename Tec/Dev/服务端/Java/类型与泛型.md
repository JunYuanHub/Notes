## 一、类型判断  
1. equal和==用于判断是否是同一个类，不含继承  
2. isInstance()和instanceof判断是否是该类或其派生类，含继承  
3. 每个类其实都是个Class对象
## 二、泛型  
泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。  

*！！！*  
*Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。*  
## 三、泛型应用  
### 1. 泛型类  
使用泛型的时候若传入泛型实参，则会根据传入的泛型实参做相应的限制，起限制作用。  
      
如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。
```  
//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，"可以"指定T的具体类型
public class Generic<T>{ 
    //key这个成员变量的类型为T,T的类型由外部指定  
    private T key;

    public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定
        this.key = key;
    }

    public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定
        return key;
    }
}
```  
注意：
1. 泛型的类型参数只能是类类型，不能是简单类型。(Integer String 不能是int char)
2. 不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错  
   `if(ex_num instanceof Generic<Number>){ }`  
### 2. 泛型接口  
1. 继承泛型接口时，未传入泛型实参，派生类必须保留泛型声明  
2. 若传入实参，派生类可不保留泛型声明  
### 3. 通配符？  
实参，类似Integer,String  
当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。
### 4. 泛型方法  
1. 泛型方法，是在调用方法的时候指明泛型的具体类型  
    ```  
    /**
     * 泛型方法的基本介绍
     * @param tClass 传入的泛型实参
     * @return T 返回值为T类型
     * 说明：
     *     1）public 与 返回值中间<T>非常重要，可以理解为声明此方法为泛型方法。
     *     2）只有声明了<T>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。
     *     3）<T>表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。
     *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。
     */
    public <T> T genericMethod(Class<T> tClass)
    ```  
2. 静态方法中的泛型  
静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。  
### 5. 泛型边界  
泛型添加上边界，即传入的类型实参必须是指定类型的子类型
### 6. 泛型数组  
不能创建一个确切的泛型类型的数组  
```  
X List<String>[] ls = new ArrayList<String>[10];
√ List<?>[] ls = new ArrayList<?>[10];
√ List<String>[] ls = new ArrayList[10];   
```