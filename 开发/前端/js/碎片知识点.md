## 奇淫技巧  
1. 数组操作  
    ```
    1. 求和：eval(arr.join("+"))
    2. 生成顺序数组：Array.from({length:10},(item,index)=> index+1) || \[...new Array(10).keys()\]  
    3. 判断数组包含：array.includes()
    ```    
2. Object处理：  
   ```  
   1. Object.assign(o1,o2,o3)将23可枚举的属性全部复制到o1，重复的属性会覆盖。  
   2. Object.prototype.toString.call(obj)用于判断类型最方便。         
   ```

## 一、ES6知识点  

### 箭头函数  
1.不绑定this=>也就不能当构造函数  
2.不绑定arguments  
3.不能使用yiled，也就是说不能当生成器  
  
### let和var  
1. 暂时性锁区  
2. 块级作用域  
3. 重复声明报错  

## 二、assign  
~~~
// Object.assign(target,…sources),
// 当target和sources对象中有相同的key时，
// 在target对象中的值会被后面source对象的值覆盖。不同则添加  
var o1 = { a: 1 };
var o2 = { b: 2 };
var o3 = { c: 3 };

var obj = Object.assign(o1, o2, o3);
console.log(obj); // { a: 1, b: 2, c: 3 }
console.log(o1);  // { a: 1, b: 2, c: 3 } 
// target对象自身会被修改

// 想要避免o1被改变，需要这样写：
var obj = Object.assign({},o1,o2,o3);//给一个空对象作为target，这样改变的是空对象
console.log(obj);// { a: 1, b: 2, c: 3 }
console.log(o1); // { a: 1}
~~~  
## 三、new操作符  
```  
// 新建，继承，执行并绑定，返回
function newFunc(con,...args) {
    let obj = {}
    obj.__proto__ = con.prototype
    let result = con.apply(obj,args)
    return result instanceof Object ? result : obj
}
```