# 一、优化实践  
1. PureComponent与immutable结合使用，自带componentShouldUpdate，含有浅比较。  
~~~  
浅复制：
Object.is() 判断两个值是否相同。类似===运算符。但===和==会将数字值-0和+0视为相等，并认为Number.NaN不等于NaN。is不会  
对于引用类型，会判断是不是同一个引用，如果不是，哪怕这两个对象中的内容完全一样，也会被认为是两个不同的prop。避免了耗费性能的递归检查。  
~~~  
# ref  
建议使用：`<div ref={(div)=>{this.ele = div}}>a</div>`,不会出现内存泄漏  
# 高阶组件  
其实就是个函数。  
一个组件许多场景下需要复用，少数情况下需要区别使用。我们把区别写入高阶组件，通过传入额外参数，动态改变差异。  
如果嵌套了多层高阶组件，会出现高阶组件地狱。  
# 受控组件和非受控组件  
受控组件：组件改变完全受控于数据变化，数据变化，组件也变化  
react中受控组件会更好，react是数据驱动式框架，受数据控制会更好  
# Hooks  
# ajax请求发送在哪个生命周期？  
componentDidMount  
SSR项目中，willmount被用来获取服务端数据，不能被占用  
# ssr  
# redux-saga,sidEffect  
我们将这些操作称为“副作用”（或简称为“效果”），因为它们会影响其他组件，并且在渲染过程中无法完成。